Data structure :

A data structure is a storage that is used to stack and organize data.It is a way to arranging data on a computer so that it can be accessed and update eficiently .

Types of data structure :

1.Linear vs non linear

2.Static vs Dynamic 

                  Static 	                                            Dynamic

1.	Memory allocated on compile time 	                1.memory allocated on runtime
2.	fixed : once allocated can not be changed
 	                                                        2.on demand : can increase or decrease as per need 
3.	memory allocated on predict 	                        3.memory allocated on demand only

4.	 Not memory efficient
 	                                                        4.memory efficient as per need 
5.	Easy to allocate : int a =10 ; //4 byte in java
 	                                                        5.many languages needs special commands to give c++ :new / delete
	




ADT:

1 . create(size) - creates array/stack of n size , init tos -1 

2 . push(e) : enter element on stack by tos + 1 

3 . pop() : removed element from stack[tos] , tos - 1

4 . isFull : T/F returns true if full else false

5 . isEmpty : T/F returns true if empty else false

6 . peek() : e return element at tos 

7 . printStack() : prints in LIFO manners from tos to 0 


Applications :

1.Recursion

int fact(int no)
{
if(no == 1)
 return 1;
else
return no*fact(no-1);
}
---------------------------------------------------------------------------------------------------------------------------------------------------------

2.Wellness or Balance of { [ ( ) ] }
 // .length is property in array
	   // .length() is method in String
-check wellnesss or balance - equal number of opening and closing brackets

cases / conditions :
1.completely balance
2.expected - one bracket '}' is remaining 
3.unexpected - one bracket '}' is extra


output

{ { {  } } -> string inputs

-use stack ->push
           ->pop

1.balance

2.expected

3.unexpected

-----------------------------------------------------------------------------------------------------------------------------------------
3.Decimal to Binary conversion

- take remainder and put on stack
- at end remove data from stack and accept it as answer

1 2 4 8 16 32 64 

(12) binary = 1100

eg 1%2 = 1

- assignment

-----------------------------------------------------------------------------------------------------------------------------------------------

4. Reversing a String 

" java "
  
- char by char 

- push(e) and then pop 

a    
v   av
a   ava
j   avaj

-----------------------------------------------------------------------------------------------------------------------------------------------

5.Expression and Evaluation Conversion

    1. Infix ( operator in between two operands) a+b eg for human
    2. Prefix  +ab  --> this is for software  -->add(a,b) 
    3. Postfix  ab + -->this is for hardware  -->load a , load b , add a,b eg physically handle calculator 


BODMAS RULE 

1.always go left to right
2.first solve higher then lower ( ^ highest ; * , / , % higher ; + , - lower )
3.in case of brackets start from inner most


eg a+b-c
    
postfix -> ab+c-
Prefix -> -+abc 

eg a + b * c / d + e
     3   1   2   4

postfix -> a + bc * / d+e -> a+bc*d/+e -> abc*d/++e -> abc*d/+e+

prefix -> a+/*bcd +e -> +a/*bcd+e -> ++a/*bcde


eg a+b*c-d*e

postfix -> a+bc*-de* -> abc*+de*-

prefix -> *+abc*-de
  

eg (a+b) * (c -d)

prefix : *+ab-cd
 postfix : ab+cd-*  


@ using stack palindrome , decimal to binary      


----------------------------------------------------------------------------------------------------------------------------------------

Infix to Postfix 

1.go left to right
2.if operand copy to postfix
3.if {[( push on stack
4.if }]) pop all till ([{ and copy poped to postfix
5.if operator push iff precedence(new) > precedence(tos_operator)
else pop till condition statisfies of stack becomes empty



Infix to Prefix 

1.go right to left (end to start)
2.if operand copy to prefix
3.if }]) push on stack
4.if {[( pop all till }]) and copy poped to prefix
5.if operator push iff precedence(new) >= precendence(tos_operator)
else pop till condition statisfies or stack becomes empty
6.reverse and print prefix


a+b*c

c b * a +	

prefix = +a*bc


*   +


similar like --> shallow deep shallow concept read

String s1 ="java" , s2="java";
s1.CompareTo(s2)  -> check the content
s1==s2  --> check the reference  , create a shallow copy 


5 + 3 = 5 , 3 , + = 5 3 +


Evaluation of postfix expression 

 2 3 1 * 9 -

100 , 200


Evaluation of prefix expression 




Min Stack

minStack.pop()  -> 


maxStack 

-when push check peek of maxstack if element > maxStack[tos]


2 push -> stack
       -> maxStack

pop -> if stack[tos] = maxStack[tos]

2 pop ->stack
      ->maxStack



Q.One single array using 2 stack
2stack  - 1 array


-----------------------------------------------------------------------------------------------------------------


Queue


-FIFO First in First out
1.Enqueue - entry on queue  ->rare+1

-queue is doulble ended 1.rare 2.front
-nature is FIFO
-it is linear and most static 
eg.line 
-as per mcq
-queue empty condition is front>rear - front is ahead with rare

-what is not empty condition - front<rear

drawback - one time used 

Types of queue
1.Linear queue
2.Circular queue
3.Priority queue


--------------------------------------------------------------------------------------------------------------------
Q.
- Linear Queue spaces can be used only once 
- One can not reclaim spaces that got free due to dequeue

solution :-Circular queue eg youtube nuffer and rebufferinh the size

-enqueue/dequeue : count 
   ->enqueue --> count+1
   ->dequeue --> count-1

Incrementing formula for

1. rear = (rear + 1) % Maxsize

2. front = (front + 1) % Maxsize

Full if count == Maxsize
empty if count == 0 

-------------------------------------------------------------------------------------------------------------------

Priority Queue

- NOT LIFO OR FIFO BUT  IN THIS ON EVERY DEQUEUE MAXIMUM/MOST IMPORTANT PRIORITY WORKS COMES OUT 

                   F
eg. 8  17  80 2 5 10
                R  

1 . Ascending priority of queue 

dequeue() -  2,5,8,10,17,80

2. Descending priority queue
-total system

dequeue() - 80,17,10,8,5,2

=====================================================================================================================

Dqueue-Double ended queue


====================================================================================================================

  SLIDING WINDOW PROBLEM

- interview questions  find maximum on sliding window or minimum of sliding window based on queue.

Q.Implement sliding window on queue that returns max in window for each slides example output given above


-----------------------------------------------------------------------------------------------------------------------------------------------------------------


LINKED LIST

1.Linear linked list
-unidirectional in nature 
  root
|  |   | -> |  |  |  -> |  |   |


2.Circular linked list (use for looping)

  root                    last
 |--|  |   | -> |  |  |  -> |  |   |-----|
 |_______________________________________|


3.Doubly linked list
drawback : - unidirectional 
Solution :
-i has previous last i.e left and right


4. Circular doubly linked list 



- It is linear-dyanamic structure most powerful as can code all 5 types of DS uses node

- def:  Collection of nodes in sequential manner 
 ____________________
 |   data  |  next   | node ->node is combination of data and next
 |_________|_________|


class Node
{
   int data;
   Node next;  //self reference ->node referring to another node
   Node(int data)  //constructor
   {
      this.data = data;  ->pointers can refer to its own type

      this.next=null; 
   }
}

 ____________________
 |   10    |  null   | 
 |_________|_________|

Node n = new Node(10);

-called by  constructor and return the node


**Note : ROOT IS 1ST OR LEFT MOST 
(root will be assigned to 1st)
- RIGHT MOST HAS NEXT NULL
- accessed in sequential manner(squential linear dyanamic linked list)
- 

10  2000  ->  20 3100  -> 30 4800 -> 40 null



Node t = root;  //t=1200
T = t.next; //t=2000

Has a -> containership -> linked list follow

Is a -> inheritance 

nullify the root -> assigning it null so we know when to use it

ADT :

List

1. insertLeft(e)
 ROOT IS 1ST OR LEFT MOST 
-create a node and check any root will exists
-check root is null or not , then set it is root
-connect root to next 
-then root is on first


2. insertRight(e)
RIGHT MOST HAS NEXT NULL
- simply connect to root


3. deleteLeft(): e

- consider one temporary variable t 
- if root is null then list is empty
- copy the root node
- root=root.next -> conect next with root
- we are deleteing by creating local variable -> t 
- we just displaying what is deleted t.data



4. deleteRight() : e

- declare t2 as anchor means as reference

5. printList():
6. searchList(key):

ADV :

1. insertAt(pos,data)
2. deleteKey(key): search and delete 

Circular Linked List

- root and last 
-first thing root and last is null
-root refer itself





Dynamic Stack:
ADT:
createStack()
push(e) :insertLeft(e)
pop() : e :deleteLeft
peek() : e :printLeft
print() :LIFO tos till null

linear linked list la dyanamic madhe convert kely 
- root repplace with tos
-


can you implement stack left or right side ?

- it is possible usng left 
- if we moving towards right previous nodes link will be disconnected , printing in lifo will not be possible 



Queue using linked list

Enqueue() : insertRight
Dequeue() : deleteLeft
print() : left to right


implement queue in another way means insertleft , deleteright - it is possible but its printing not in fifo manner


 ****************** Linked list ****************************
insert at 




Create a menu driven CRUD operation program for employee management using linear linked list

Linked list maintains data:
employee_id , Name , Gender , Salary

Menu :
1.insertRight: - register a new employee(goes at of end of list)
2.search an employee on his\her number
3.Update old record on employee id
 
  ->update -> ask for id ->if found   1.name  2.gender 3.salary

4.Delete record on id 

**********************************************************************************************************************************************************************


Tree

- at most , at least - only one root 
-if you looking at situation which has multiple roots called data forest tree
-leaf nodes 
-branch nodes

---------------------------------------------- 

Binary tree ( 0 and 1 )

- a node can at most have two child nodes.
- at most 0 , 1 , 2 nodes

-----------------------------------------

Terms
1.Depth 
2.Height 
3.Subtree 
4.Ancestor ( root ) 
5.Leaf node - end of the tree 
5.Root node


depth and height

-depth and height of tree is equal but depth and height of node may not be equal
-length of longest running branch

---------------------------------------

Types of Binary tree

1 .  Complete 
-All leaf nodes are at same depth

2.Nearly complete
-All except 1 is at depth +-1
-ek koi age reh jaye or ek piche reh jaye

3.Strict
-each node can have either two child or zero

4.Binary search tree
-Child to left < Parent 
-Parent <= right child

left child < Parent < right child 

-------------------------------------------------

Construct binary search tree
10,2,7,1,20,15,11,22,28

-------------------------------------------------



* ************Tree traversal****************** *
traversal - order of visiting each node

-------------------

       (P)
        + 
      /  \
 (L) a    b (R)
 
------------------ 

 +   a   b  Preorder
(P) (L) (R)


 a   +   b Inorder
(L) (P) (R) 

 a   b   +   Postorder
(L) (R) (P)


p: print
L: go to left
R : go to right


----------------------------------------------------------------------------------------------------------------------------------------

Threaded Binary Tree

- Enhanced form of tree for simple inorder traversal
- Why inorder ? because as inorder data is sequential/serial access of data 
- need ? today data is stored on tree is scattered manner, one may need to access it in order . Example OverTheTop:Webseries


1.one handed : 
-either left/right to refer next
-next : inorder next is refer


2.two handed
- L:previous R:next :- traversal becomes easy


-------------------------------------------------------------------

Applications of tree
1.Storage
2.Searching and sorting large scale data
3.Autocorrect Auto Complete(dictionary tree used)
4.Expression tree for conversion and evaluation
5.In GIS System(satellite map zoom in-out)




---------------------------------------------------------------------

Balance Factor = height of left subtree - height of right subtree
-balance factor : it reduces the height and depth of the tree

-Every node has it 
balance tree can be accessed faster

AVL tree

-self balancing tree
- nearly balance  (balance factor  +1  , 0 , -1 )
- binary tree

- If balance factor +1 < | -1 >(out of +1 & -1 range)  unbalance then we rotate on basis of where and who caused unbalance

---------------------------------------------------------

Four rotation to  balance out

1.Left of Left - niche se upper follow hota hai

2.Right of Right

3.Right to Left

4.Left of Right

----------------------------------------------------------------------------

AVL

- insertion one at a time in BST manner
- After every insertion calculate Balance factor for all node bottom  to top
- stop at 1st location where balance factor goes beyond +1 to -1
- search 3 node path from unbalanced to newly inserted that caused unbalance.
- check case and apply rotation

If there are n nodes in AVL tree, minimum height of AVL tree is floor(log2n).
If there are n nodes in AVL tree, maximum height can’t exceed 1.44*log2n.
If height of AVL tree is h, maximum number of nodes can be 2h+1 – 1.
Minimum number of nodes in a tree with height h can be represented as: N(h) = N(h-1) + N(h-2) + 1 for n>2 where N(0) = 1 and N(1) = 2.
The complexity of searching, inserting and deletion in AVL tree is O(log n).
---------------------------------------------------------------------------

Multiway Search Tree

- In a node one can store multiple elements
- Data at a node is sorted
- has order M that decides minimum and maximum split
 that is  1.min(M/2)
          2.max(M-1)
          3.Split(M)
- M must be odd 
ex. M:3 
min elements at a node is M/2 = 3/2 = 1
max elements at a node is M-1= 3-1 = 2
split  elemets at a node M = 3 mid split

- Insertion only in leaf nodes
- All leaf nodes are at same depth
- On split child will create parents and parents will create grandparents

Q . What is the problem in B tree ?

 - drawback - data is scattered in n nodes and for sequentiaal access one must go through all nodes.

ex 1 to 7 access krna hai you need to go 1 to 2 to 3 to 4 to 5 to 6 to 7 ....


*** Btree diya rehta hai b plus banane ko kehte hai **********

--------------------------------------------------------------------------------


 B + tree

- it is enhanced form of b tree for sequential access
- All things from B tree
- But in this all data kept only in leaf nodes on split only reference is given to higher nodes and all leaf nodes are interconnected

-----------------------------------------

Deletion of a node from binary tree :

case 1: leaf 

sol : cut from parent and delete
 
case 2 : parent with single child

sol : connect grand parent to grand child

case 3 : parent with complete left and right subtee

sol : inorder next takes the position  


*****************************************************************************************************************

Representation  of Tree

1.Static (array)

- root : oth position
- i'th  --> 2i+1(left child)
            2i+2(right child)
+ve : simple fast
-ve : static so can not grow or shrink , not memory efficient

2.Dyanamic (DLL)
- uses DLL node to create tree
+ve : Dyanamic and can grow/shrink as per need , memory efficient
-ve : due to one directional reference can only go from top to bottom , hence recursion is to use 
 
3.Dyanamic (Tree node)

- Uses special tree node that has 3 way connectivity

+ve : dyanamic can grow/shrink as per need , has both reference top to bottom and bottom to top
-ve : too complex to implement

******************************************************************************************************************

-----------------------------------------------------------
Tree Implementation using DLL(Doubly linked list) approch
-----------------------------------------------------------



GRAPH

-------------------------------------------------

- Every tree is  graph but
- Every graph is not a tree -->tree with cycle is a graph 

- Graph without cycle is a tree

Graph : 
    Collection of nodes / vertices that are interconnected via edges/links

G( V , E )  -> V = set of vertices
            -> E = set of edges 
 *********************************************************************************************************************

Types of Graph

1.Unweighted -> basic connection
2.Weighted -> Any unit that can be used to take decision , common unit -> cost , delay , distance , bandwidth
           -> shows connection with cost
3.Undirected -> Symmetric
4.Directed  -> Asymmetric 
----------------------------------------------------------------------------------------------------------------------------------------------

Applications

1. In routing
2. In biometric eg .retina scan , fingerprint scan ( used for security) - graph
3. Searching in graph - DFS , BFS , Blind search , least cost search
4. Handling flow problem  -> how to manage
5. Topological sort
   -> Kind of graph in which each ith state must be reached only after i-1'th state
   -> Manufacturing / production , cooking 
   -> We cannot skip any step eg our eduacation system you -> born -> kg -> ssc -> hsc -> BE -> mE -> PHD 
                                                                             Diploma             MS

6. Google Maps uses graphs for building transporatation systems , wher intersection of two roads are considered to be a vertex and the road connecting two vertices is considered to be an edge , thus their navigation system is based on the algorithm to calculate the shortest path between two vertices .

7. In Facebook , users are consisdered to be the vertices and if they are friends then tere is an edge running between them .Facebooks friend suggestion algorithm uses grapH theory . FACEBOOK IS AN EXAMPLE OF UNDIRECTED GRAPH.

8.In OS , we come across the resourses alllocation graph where each process and resources to be vertices.used in resource allocation and deadlock
--------------------------------------------------------------------------------------------------------------------

Terminologies:


1.Adjacent Nodes : Two nodes are adjacent if they are connected by an edge

2.Path : A sequence of vertices that connect two nodes in a grapgh

3.A simple path is a path in which all vertices except possibly in the first and last are different .

4.Complete graph : A graph in which every vertex is directly connected to every other vertex eg ,mesh architecture is complete graph

5.A cycle is a simple path with the same start and end vertex.

---------------------------------------------------------------------------------------------------------------------------------

DEGREE OF NODE

- number of elements that are connected
- The degree of vertex / is the no. of ehges incident on vertex

-Direcected grph degree is of two types indegree and outdegree
1. indegree - > no .of incoming edges
2. outdegree -> no of outgoing edges

-*--------------------------------------------------------------------------------------------------------------------------

CELEBRATIY NODE :

- Maximum incoming (v-1) and outgoing (0) zero or nearly none 

- In oder to find most popular additionof column is used.

indegree (incoming) = addition of column

------------------------------------------------------------------------------------------------------------------

REPRESENTATION OF GRAPH to computer is

1.Adjacentry natrix
- static 
- easy
- to fill if unweighted  1 / 0
-to fill weighted W / infinity

- 16 is considered to be infinity with reference to computer network.

2.Adjacency List

- array of linked list
- each node is an edge
- can grow or sharing with need
- storage of ( v+e )

-----------------------------------------------------------------------------------------------------------------------------------------

DIJKSTR'S aLGORITHM / SHORTEST PATH FIRST(SPF) /SINGLE SOURCE SPF

lOGIC :

1. initially all marked as { - (from) , infinity (cost) }

2. source is { - , 0 } to start

Steps :

1.select minimum unvisited mark it visited ,forwards its weight to unvisited neighbours update weight iff new weight is smalller than old


2.end:When all are visited /or/destination reached

-----------------------------------------------------------------------------------------------------------------------------------------

MINIMUM SPANNING TREE (MST)

-Application of graph

input : graph
output : tree

Process : remove cycles and keep only minimum cost edges

MST used in roads , transport , rail , piping  , wiring , broadcasting (no cycles)

*****************************************************************************

Algorithm in MST
 
How many edges in MST (v-1)
MST cost means addition of tree edges weight 

1.Prim's : works on node/vertices , has more control 
- exploring the chepest path
    step 1 : start from given source ass it to sol tree
    step 2 : while all vertices are not in sol tree do
                1. Select the cheapest edge between vertex of sol tree and non-sol vertex iff not forming cycle 

----------------------------------------------------------------------------------------------------------------------------

2.Kruskal's : works on edges / has less control over solution ( any edge from anyside as per need gets connected results in disconnected graph inbetween)
      step 1 : create sorted list of all egdges on basis of weight
      step 2 : till all nodes are not in solution do 
                    1.extract an edge from sorted list
                    2.check if not forming cycle then accept in sol else reject and go to step

*** BOTH WILL GIVE SAME RESULT ***** -> MST cost

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

Graph Searching
- Both Blind search

1.BFS 

-> Queue 
-> Horizontal search

Step 1 :Start by putting source on QUEUE and marking it visited

step 2 :Search for All UNVISITED neighbours of element at queue front , mark them visited and put them on queue

step 3 : remove element at queue front

step 4: continue 2,3 till queue is not empty

------------------------------------------------------------------------------------------------------------------------------

2.DFS

-> Stack
-> Vertical search

step 1 : accept source , mark it visited and push it on STACK

step 2 : search any ONE UNVISITED neighbour of element at top of stack , mark it visited push it on stack

step 3 : if no unvisited element found then pop element from stack at go step 2

step 4 : continue step 2,3 till stack is not empty 


******************************************************************************************************************************************************

How to find adjacency path using matrix ?
//todo




Algorithms

finite set of steps
-set of finite steps followed will solve given given problem in finite step and finite time .

------------------------------------------------------------------------------------------------

5 pillars of algorithm

1.Input - data/ dataset / problem set
2.Output - result(true) / response (fail) 
3.Finiteness - fixed steps and time
4.Definiteness - each step should be clearly defined to implement 
5.Effectiveness - Each step should either take us closer to solution or solve the problem

// Most important pillar is Input and Output  


Analysis 

why ?
- So one can predict time and space complexity and then select the one .

When ? 
1.Priori
- Done before implementation
- Using pen paper

2.Posteriori ( 1. rechecked what priori analysis give us 2. what improvement needed )
- Done after implementation
- Using software by professionals

on What ?
1. Best case  - 0% to 1-2% work }    efficient and
2. Worst case - 100% to 200%    }     accurate answer
3. Average case - 50-60% work ->if you need speed / quick answer

What we get ?

1.Time complexity

T(P) = t(compile)(P) + t (execute)(P)
           1                n

- Times which we giving is in steps 

Comments ----> 0
Operation ---> 1
Loop ---> n+k   --> n+

2.Space complexity

S(P) = s(variables & constants) (P) + S (instructions) (P)



Aymptotic Notation

- A way of recording complexity using mathematical formula / unit of recording complexity

- Aymptotic Notation  is used to describe the running time of an algorithm - how much time an algorithm with a given inmput n

- Algorithm Common Runtimes

Fastest to slowest are
1 . Constant      --> O(1)
2 . Logarithmic   --> O(log n)
3 . Linear        --> O(n)
4 . Polynomial    --> O(n^2)
5 . Exponential   --> O(2^n)
6 . Factorial     --> O(n!)

           Symbol            used

Big Oh -->   O          --> only worst case    --- > O(n²).                        --> f(n) <= c.g(n)   --> c is constant
                       --> max used , simple but less accurate , fast

Theta -->   0 (theta)  --> average of ( worst and best)    --> Θ(n×p)             --> c1.g(n) < = f(n) < = c2.g(n)
                       --> slow but high accuracy

Omega -->   Ω           --> best case only                                        --> f(n) >= c.g(n) 
                       --> not used
                  


      f(n)                          g(n)

- input rate                   - growth rate       

- no rate                     - amount of steps



Big Oh ' O ' Notation 


Rules
1.Constant has no value
 
O(100n) --> O(n)

2.In addition use max(worst only)

O(n) + O(n^3) + O(n^2) --> O(n^3)

3.In nesting multiply and then use addition rule

O(n).O(n+3)
O(n^2) + O(3n)  -->o(n^2) + (n)   --> O(n^2)
             
-------------------------------------------------------------------------------------------


First performed sorting and after that searching will takes place 

---------------------------------------------------------------------------------
1.Sorting is first and faster

------------------------------------------------------------------------------------

Sarching

- result is i'th index(found) response is -1 (not found)

--------------------------------------------------------------------------------

1.Sequential search / Serach search / linear search

Why linear search uses unsorted array ?

- Only search that can work on unsorted data 
- Simplest form of search

 step 1 :  linear Search(array , key): i/-1
 step 2 :  Start from 0th and search till last element 
                  if found stop and return location
                       at end return -1
int LinearSearch(int a[] , int key)
{
    for(int i=0;i<a.length;i++)
    {
          if(key == a[i])
               return i;  //found
    }
    return -1 ;   // not found

}

-----------------------------------------------------------------------------------------

2.Binary search

How would ypu improve  the binary search

- first checking extreme boundaries and then starting 

 
- Can only work with sorted data
- Uses divide and conquer tech

-In search array must be sorted .

step 1 : Calculate mid =( start + end )/2;
step 2 : if key == a[mid] then say found at mid
         else
         {
            if key is lesser then a[mid] go to left half
            else goto tight half
         }
step 3 : if start and end crosses each other then 
         not found(-1) 

-***********************************************************************************-

Sorting Process

- it is a placing / arranging data in some order.
- Default(Ascending) min to max
- Descending max to min
- done for faster search as arranged data can be searched quickly

---------------------------------------------------------------------------------------------------

Why insertion sort is ccalled inseartion sort ?
Why n-1 in bubble sort?

----------------------------------------------------------------------------------------------
Bubble Sort

-heavy to lighsest
- elements in bubbled on the top in each pass needs n-1 passes

void BubbleSort(int a[])
{
   int i , j , t;
   for(i=0;i<a.length-1;i++)  // gave only passes
   {
        for(j=0 ;j<a.length-1;j++) // j stops at second last 
        {
             if(a[j]>a[j+1])
             {
                t = a[j];
                a[j] = a[j+1];
                a[j+1] = t;
              }
        }
   }
}


----------------------------------------------------------------------------------------------------------------

Selection Sort

-  select the minimum search
-  lighestest to heavy

- In each ith pass selects smallest element and place it at ith location.
- min to max in sorting ( 0 to n -1 )
- n-1 passes at most
- search for min in each pass
 .


void selectionSort( int a[] )
{
   int i , j , min ,pos ;
   for(int i = 0 ; i<a.length-1;i++)
   {
        min=a[i];
        pos = i ;
        for(int j = i+1 ; j<a.length;j++)
        {
            if(a[j]<min)
            {
                min = a[j];
                pos = j ;
            }
         }
         a[pos]=a[i];
         a[i] = min;
    }
}   
-----------------------------------------------------------------------------------------------------------------------

Insertion Sort 
- Array in div in 2 parts (sorted/unsorted)
- in each pass an element from unsorted is taken and inserted in sorted part at right location 

void insertionSort((int a[])
{
   int i , j , new_element;
   for(i=0;i<a.length-1;i++)
   {
       new_element = a[i+1];
       j=i+1;
       while(j>0 && a[j-1]>new_element)
       {
            a[j] = a[j-1];
            j--;
       }
        a[j] = new_element;
    }
}
 
-------------------------------------------------------------------------------------------------------------------------

Quick sort

- works on pivot (ref position)
- pivot : start* , end , miid

- we take pivot and rearange array such that elements before pivot < pivot < after pivot
- fastest
                   -  aage vale pivot se  chote hone chahiye and piche vale pivot se bade hone chahiye

void quickSort(int a[] , int start , int end )
{
     int i = start ;
     int j = end ;
     int pivot = start;
     while(i<j)
	{
		while(a[i]<a[pivot])
		    i++;
		while(a[j]>a[pivot])
			j--;
		if(i<j)
		{
			int t=a[i];
			a[i]=a[j];
			a[j]=t;
		}
	}
	if(i<end)
		quickSort(a,i+1,end);
	if(j>start)
		quickSort(a,start,j-1);
    
}

Merge Sort

- divide and conquer - it is special algorithm problem size is larger than the process
- Start with 1 array of n elements , divide from middle again and again till we reach to n arrays of 1 element then we start merging them in order
- Known for it parallel implementation can do large scale data sorting.(when your machine support multithreading or multitasking)
O(nlogn)
eg real life pizza you can eat by cutting it in separte pieces or second one engineering 4 years explain well 

void mergeSort(int a[] , int start , int end)
{
	if(start<end)
	{
	       int mid=(start+end)/2;
		mergeSort(a,start,mid);
		mergeSort(a,mid+1,end);
		merger(a,start,mid,end);
	}
}     
void merger(int a[],int start , int mid , int end)
{
	int i,j,temp[],tindex;
	temp=new int[a.length];
	i=start;
	j=mid+1;
	tindex=start;
	while(i<=mid && j<=end)
	{
		if(a[i]<a[j])
			temp[tindex++]=a[i++];
		else 
			temp[tindex++]=a[j++];
	}
	while(i<=mid)
		temp[tindex++]=a[i++];
	while(j<=end)
		temp[tindex++]=a[j++];
	for(i=start;i<=end;i++)
	{
		a[i]=temp[i];
	}


}

-------------------------------------------------------------------------------------------------------------------------------

Heap Sort

- uses idea of heapify tree
- loosely based on heapify processwhich is tree based sorting
- Heapify : a tree that can be MAX heap / MIN heap 
                
                MAX heap : parent have greater value than child parent > child
                MIN heap : parent have lesser value than child parent < child

- Heapify uses Array implementation of tree ( 0 th root , i'th 2i+1 , 2i+2 child)

- go bottom to top , left to right and check max / min heap if needed swap
- at end swap last and root
- cut last 
- restart with leftover to create tree

- j is a mid level node from where child to parent and parent to grand parent starts checking 
     pc   : child
     pc/2 : parent
 
     if a[pc/2] < a[pc]
        parent < child 
     then
        swap
 

void heapSort(int a[] )
{
    boolean done;
    for(int i=a.length-1;i>-1;i--)
    {
	for(int j=0;j<=i;j++)
	{
		int pc = j;
		done=false;
		while (pc > 0 && pc/2>=0 && done!=true)
		{
			if(a[pc]>a[pc/2])
			{
				int t = a[pc];
				a[pc] = a[pc/2];
				a[pc/2] = t;
				pc=pc/2;//move to parent
			}
			else
			{
				done = true;
			}
		}
		int t = a[0];
		a[0] = a[i];
		a[i] = t;
       }
   }
}
	
---------------------------------------------------------------------------------

Hashing 

eg . QR - finding anything in one pass , barcode ( credit , debit card)

- Hashing is a process of finding needed data in a pass 

- Components of hashing 

data  -----> hash function  ------------> index i
     data i                   index i     Data i

eg.
-- when you create a contact -> save -> gave a hash code -> in memory wo contact ready hota hai ->when you call up then u get clip ( number screen dikhta hai ) then it will gave number to hash function and create hash value  --> calling 


IMPORTANCE in hashing

1.Hash function 
  - should be fast
  - should spread
  - no collision
  - easy to code

2.Hash Table 
  - Saves the data as given index and hence important with respect to speed of access and size
























































































